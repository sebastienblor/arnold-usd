<fragment  uiName="aiRectangleAreaLight_2020" name="aiRectangleAreaLight_2020" type="lighting" class="ShadeFragment" version="1.0" feature_level="0" >
    <description>
<![CDATA[
Computes irradiance from a rectangle area light, w/ specular]]>
</description>
    <properties>
        <float  name="lightOn" flags="isNotSharableParam" />
        <bool  name="lightActive" flags="isNotSharableParam" />
        <float  name="intensity" flags="isNotSharableParam" />
        <color  name="color" flags="isNotSharableParam" />
        <float  name="emitsDiffuse" flags="isNotSharableParam" />
        <float  name="emitsSpecular" flags="isNotSharableParam" />
        <float3  name="LP0" flags="isNotSharableParam" />
        <float3  name="LP1" flags="isNotSharableParam" />
        <float3  name="LP2" flags="isNotSharableParam" />
        <float3  name="LP3" flags="isNotSharableParam" />
        <float3  name="Pw" flags="varyingInputParam" />
        <float3  name="Nw" flags="varyingInputParam" />
        <float3  name="Vw" flags="varyingInputParam" />
        <float  name="decayRate" flags="isNotSharableParam" />
        <bool  name="normalize" flags="isNotSharableParam" />
    </properties>
    <values>
<float name="lightOn" value="1.000000"  />
<bool name="lightActive" value="false"  />
<float name="intensity" value="1.000000"  />
<color name="color" value="1.000000,1.000000,1.000000"  />
<float name="emitsDiffuse" value="1.000000"  />
<float name="emitsSpecular" value="1.000000"  />
<float3 name="LP0" value="-10.000000,10.000000,-10.000000"  />
<float3 name="LP1" value="-10.000000,-10.000000,-10.000000"  />
<float3 name="LP2" value="10.000000,-10.000000,-10.000000"  />
<float3 name="LP3" value="10.000000,10.000000,-10.000000"  />
<float name="decayRate" value="0.000000"  />
<bool name="normalize" value="false"  />
    </values>
    <outputs>
        <struct  name="aiRectangleAreaLight_2020" struct_name="irradiance" />
    </outputs>
    <implementation  >
    <implementation  render="OGSRenderer" language="Cg" lang_version="2.100000" >
        <function_name val="aiRectangleAreaLight_2020" />
        <source>
            <![CDATA[
// Find the closest point to a rectangular light source in 3D space
// ********************************************************************************
float3 aiNearestPtOnLt( float3 ltPts[4], float3 ltCenter, float3 Pw )
{ 
    // finds the closest point
    float3 V = ( ltPts[1]-ltPts[0] ); 
    float lenV = length( V ); 
    V /= lenV;  lenV *= 0.5; 
    float3 U = ( ltPts[3]-ltPts[0] ); 
    float lenU = length( U ); 
    U /= lenU;  lenU *= 0.5f; 
    float3 L = Pw - ltCenter; 
    float LU = dot( L, U ); 
    float LV = dot( L, V ); 
    float3 Lw = ltCenter 
                 +  U * clamp( LU, -lenU, lenU ) 
                 +  V * clamp( LV, -lenV, lenV ); 
    return Lw;  
} 

float3 aiPlaneIntersection(float3 ray, float3 planeNormal, float3 ptOnPlane, float3 rayOrigin)
{
    float deltaD = dot(ptOnPlane, planeNormal) - dot(rayOrigin, planeNormal);
    float cosA = dot(ray, planeNormal);
    float lenToEdge = abs(cosA) < 0.00000001 ? 9999999.9 : deltaD / cosA;
    return ray * lenToEdge + rayOrigin;
}

// Find the closest point to tube shaped light source along the reflection ray
// ********************************************************************************
float3 aiGetTubeReflection(float3 L0, float3 L1, float3 R, float halfHeight)
{
    float3 Ld = L1 - L0;
    float RdotL0 = dot(R, L0);
    float RdotLd = dot(R, Ld);
    float L0dotLd = dot(L0, Ld);
    float distLd = length(Ld);
    float t = (RdotL0 * RdotLd - L0dotLd) / (distLd * distLd - RdotLd * RdotLd);

    float3 closestPoint = L0 + Ld * clamp(t, 0.0f, 1.0f);
    float3 centerToRay = dot(closestPoint, R) * R - closestPoint;
    return closestPoint + centerToRay * clamp(halfHeight / length(centerToRay), 0.0f, 1.0f);
}

// find the closest point to a rectangular light source along the reflection ray
// **************************************************************
float3 aiGetStreakedReflection(float3 dL, float3 origin, float3 U, float3 V, float lenU, float lenV)
{   
    float3 vnRayAtoB = normalize(dL - origin); 

    // compute the closest point to the axis 
    float LV = dot(dL, V); 
    float vError = abs(LV) - lenV; 
    LV = clamp(LV, -lenV, lenV); 
    float3 VOff = V * LV; 
    if (vError > 0) 
    { 
        dL = aiPlaneIntersection(vnRayAtoB, V, VOff, origin); 
    } 
    
    // compute the closest point to the second axis 
    float LU = dot(dL, U); 
    float uError = abs(LU) - lenU; 
    LU = clamp(LU, -lenU, lenU); 
    float3 UOff = U * LU; 
    if (uError > 0) 
    { 
        dL = aiPlaneIntersection(vnRayAtoB, U, UOff, origin); 
    } 
    LV = dot(dL, V); 
    LV = clamp(LV, -lenV, lenV); 
    
    VOff = V * LV; 
    return VOff + UOff; 
}

float3 aiGetRectangleReflection( float3 ltPts[4], float3 ltCenter, float3 Pw, float3 Nw, float3 Vw, float area)
{    
    float3 U = ( ltPts[1]-ltPts[0] ); 
    float3 V = ( ltPts[3]-ltPts[0] ); 
    float3 R = reflect( -Vw, Nw ); 
    
    float lenU = length(U); 
    float lenV = length(V); 
    
    float uDiff = abs(dot(-Vw, normalize(cross(R, U)))); 
    float vDiff = abs(dot(-Vw, normalize(cross(R, V)))); 
  
    U /= lenU;  lenU *= 0.5; 
    V /= lenV;  lenV *= 0.5; 
 
    float3 ltN = normalize( cross( V, U )); 
    float LtPlaneD = dot(ltN, ltPts[0] ); 
    float ptPlaneDist = LtPlaneD - dot(ltN, Pw);     
    float LN = dot(ltN, -Nw);
    float NV = dot( -Vw, Nw ); 
       
    // Find the intersection point of the reflection ray and the light plane 
    // Early out if the ray does not hit the front of the light.
    // ************************************************************************************
    float LR = dot( ltN, R ); 
    if (LR <= 0.0) 
        return -R; 
    float t = ptPlaneDist / LR; 
    if (t <= 0.0) 
        return -R; 
        
    float3 Rint = Pw + R * t; 
    float3 dL = Rint - ltCenter; 

    // We compute the plane ray intersection in light plane space.
    // So compute the ray start on the light plane by projecting the surface point along the 
    // light normal until it hits the light plane.
    // ************************************************************************************
    float3 origin = Pw + (Nw * (-ptPlaneDist / LN)) - ltCenter; 
    float3 reflectIntersect = aiGetStreakedReflection(dL, origin, U, V, lenU, lenV);      

    // Next, find the intersection point of the reflection ray with a tube around the light
    // ************************************************************************************
    float3 endPoint1 = (ltCenter + U * -lenU) - Pw;
    float3 endPoint2 = (ltCenter + U *  lenU) - Pw;
    float3 radialIntersect = aiGetTubeReflection(endPoint1, endPoint2, R, lenV);

    // Project the new intersection point with the tube onto the light plane
    // ************************************************************************************
    LR = dot( ltN, radialIntersect ); 
    t = max(ptPlaneDist / LR, 0.0f); 
    Rint = Pw + radialIntersect * t; 
    dL = Rint - ltCenter; 
    
    // and clamp the intersections to the edges of the light
    // ************************************************************************************
    float LV = clamp(dot(dL, V), -lenV, lenV); 
    float LU = clamp(dot(dL, U), -lenU, lenU); 
    radialIntersect = (LV * V) + (LU * U);
 
    // Neither the clamped tube or the streaked solutions are idea in all cases
    // So we use the view angle to the light and the view angle to the surface normal
    // to blend between the two solutions.
    // ************************************************************************************
    float lightAngle = 2.0 * min(.5, min(uDiff, vDiff));
    float surfaceAngle = 1.0 - (2.0 * min(.5, abs(NV)));    
    float3 closestW = lerp(radialIntersect, reflectIntersect, min(1.0, lightAngle+surfaceAngle));
    
    // convert the closest intersection with the light back to a ray originating from the surface point.
    // ************************************************************************************
    return closestW - Pw + ltCenter;
} 

irradiance aiRectangleAreaLight_2020( float lightOn, bool lightActive, float intensity, float3 color, float emitDiff, float emitSpec, 
                      float3 LP0, float3 LP1, float3 LP2, float3 LP3,  float3 Pw, float3 Nw, float3 Vw,
                      float decayRate, bool useArea)
{ 
    float3  ltPts[4] = { LP3, LP2, LP1, LP0 }; 
    float3  T = ddx( Pw ); 
    float3  B = ddy( Pw ); 
    float3  fN = normalize( cross( T, B )); 
    Nw = (dot( fN, Nw ) < 0.0f) ? -Nw : Nw; 
    float sumNG = 0; 
    for( int i = 0; i < 4; ++i ) { 
       int nextI = (i == 3)? 0 : (i+1);  
       float3 Li = normalize(ltPts[i] - Pw); 
       float3 Ln = normalize(ltPts[nextI] - Pw); 
       float3 Gi = normalize( cross(Ln, Li) ); 
       float bi = acos( dot(Ln, Li) ); 
       sumNG += bi * dot( Gi, Nw ); 
    } 
    float ff = sumNG / 2.0f;
    float sf = 1.0f;
    float3 ltCenter = (ltPts[0]+ltPts[1]+ltPts[2]+ltPts[3])/4.0f; 
    float area = length(ltPts[1]-ltPts[0]) * length(ltPts[3]-ltPts[0]); 
    
    float3 Ls = aiGetRectangleReflection( ltPts, ltCenter, Pw, Nw, Vw, area); 
    if (useArea) 
    {
        ff = ff / area;
        sf = sf / area;
    }
    float3 clr = lightOn * color * intensity;  
    float3 Lp = aiNearestPtOnLt( ltPts, ltCenter, Pw ); 
    float3 Ld = Lp - Pw;  
    irradiance irrad; 
    irrad.diffuseI = emitDiff * clr * ff; 
    irrad.specularI = emitSpec * clr * sf; 
    irrad.Ls = normalize(Ls);  
    irrad.Ld = normalize( Ld ); 
    irrad.Lg = float4(0.0f, 0.0f, 0.0f, 1.0f); 
    irrad.lightType = 0x00115C86; // set unique light type identifier (node id)
    return irrad; 
} 
            ]]>
        </source>
    </implementation>
    <implementation  render="OGSRenderer" language="HLSL" lang_version="11.000000" >
        <function_name val="aiRectangleAreaLight_2020" />
        <source>
            <![CDATA[
// Find the closest point to a rectangular light source in 3D space
// ********************************************************************************
float3 aiNearestPtOnLt( float3 ltPts[4], float3 ltCenter, float3 Pw )
{ 
    // finds the closest point
    float3 V = ( ltPts[1]-ltPts[0] ); 
    float lenV = length( V ); 
    V /= lenV;  lenV *= 0.5; 
    float3 U = ( ltPts[3]-ltPts[0] ); 
    float lenU = length( U ); 
    U /= lenU;  lenU *= 0.5f; 
    float3 L = Pw - ltCenter; 
    float LU = dot( L, U ); 
    float LV = dot( L, V ); 
    float3 Lw = ltCenter 
                 +  U * clamp( LU, -lenU, lenU ) 
                 +  V * clamp( LV, -lenV, lenV ); 
    return Lw;  
} 

float3 aiPlaneIntersection(float3 ray, float3 planeNormal, float3 ptOnPlane, float3 rayOrigin)
{
    float deltaD = dot(ptOnPlane, planeNormal) - dot(rayOrigin, planeNormal);
    float cosA = dot(ray, planeNormal);
    float lenToEdge = abs(cosA) < 0.00000001 ? 9999999.9 : deltaD / cosA;
    return ray * float3(lenToEdge, lenToEdge, lenToEdge) + rayOrigin;
}

// Find the closest point to tube shaped light source along the reflection ray
// ********************************************************************************
float3 aiGetTubeReflection(float3 L0, float3 L1, float3 R, float halfHeight)
{
    float3 Ld = L1 - L0;
    float RdotL0 = dot(R, L0);
    float RdotLd = dot(R, Ld);
    float L0dotLd = dot(L0, Ld);
    float distLd = length(Ld);
    float t = (RdotL0 * RdotLd - L0dotLd) / (distLd * distLd - RdotLd * RdotLd);

    float3 closestPoint = L0 + Ld * clamp(t, 0.0f, 1.0f);
    float3 centerToRay = R * dot(closestPoint, R) - closestPoint;
    return closestPoint + centerToRay * clamp(halfHeight / length(centerToRay), 0.0f, 1.0f);
}

// find the closest point to a rectangular light source along the reflection ray
// **************************************************************
float3 aiGetStreakedReflection(in float3 dLIn, in float3 origin, in float3 U, in float3 V, in float lenU, in float lenV)
{   
    float3 dL = dLIn;
    
    float3 vnRayAtoB = normalize(dL - origin); 

    // compute the closest point to the axis 
    float LV = dot(dL, V); 
    float vError = abs(LV) - lenV; 
    LV = clamp(LV, -lenV, lenV); 
    float3 VOff = V * float3(LV, LV, LV);
    
    dL = (vError > 0.0) ? aiPlaneIntersection(vnRayAtoB, V, VOff, origin) : dL; 
    
    // compute the closest point to the second axis 
    float LU = dot(dL, U); 
    float uError = abs(LU) - lenU; 
    LU = clamp(LU, -lenU, lenU); 
    float3 UOff = U * float3(LU, LU, LU); 
    
    dL = (uError > 0.0) ? aiPlaneIntersection(vnRayAtoB, U, UOff, origin) : dL; 
    
    LV = dot(dL, V); 
    LV = clamp(LV, -lenV, lenV); 
    
    VOff = V * float3(LV, LV, LV); 
    return VOff + UOff; 
}

float3 aiGetRectangleReflection( float3 ltPts[4], float3 ltCenter, float3 Pw, float3 Nw, float3 Vw, float area)
{ 
    float3 V = ( ltPts[1]-ltPts[0] ); 
    float3 U = ( ltPts[3]-ltPts[0] ); 
    float3 R = reflect( -Vw, Nw ); 
    
    float lenU = length(U); 
    float lenV = length(V); 
    
    float uDiff = abs(dot(-Vw, normalize(cross(R, U)))); 
    float vDiff = abs(dot(-Vw, normalize(cross(R, V)))); 
           
    U /= lenU;  lenU *= 0.5; 
    V /= lenV;  lenV *= 0.5; 

    float3 ltN = normalize( cross( V,U )); 
    float LtPlaneD = dot(ltN, ltPts[0] ); 
    float ptPlaneDist = LtPlaneD - dot(ltN, Pw);     
    float LN = dot(ltN, -Nw);
    float NV = dot( -Vw, Nw ); 
       
    // Find the intersection point of the reflection ray and the light plane 
    // Early out if the ray does not hit the front of the light.
    // ************************************************************************************
    float LR = dot( ltN, R ); 
    if (LR <= 0.0) 
        return -R; 
    float t = max(ptPlaneDist / LR, 0.0f); 
    if (t <= 0.0) 
        return -R; 
    float3 Rint = Pw + t * R; 
    float3 dL = Rint - ltCenter; 

    // We compute the plane ray intersection in light plane space.
    // So compute the ray start on the light plane by projecting the surface point along the 
    // light normal until it hits the light plane.
    // ************************************************************************************
    float3 origin = Pw + (-Nw * max(ptPlaneDist / LN, 0.0f)) - ltCenter; 
    float3 reflectIntersect = aiGetStreakedReflection(dL, origin, U, V, lenU, lenV);      

    // Next, find the intersection point of the reflection ray with a tube around the light
    // ************************************************************************************
    float3 endPoint1 = (ltCenter + V * -lenV) - Pw;
    float3 endPoint2 = (ltCenter + V *  lenV) - Pw;
    float3 radialIntersect = aiGetTubeReflection(endPoint1, endPoint2, R, lenU);

    // Project the new intersection point with the tube onto the light plane
    // ************************************************************************************  
    LR = dot( ltN, radialIntersect ); 
    t = max(ptPlaneDist / LR, 0.0f); 
    Rint = Pw + t * radialIntersect; 
    dL = Rint - ltCenter; 
    
    // and clamp the intersections to the edges of the light
    // ************************************************************************************
    float LV = clamp(dot(dL, V), -lenV, lenV); 
    float LU = clamp(dot(dL, U), -lenU, lenU); 
    radialIntersect = (LV * V) + (LU * U);
 
    // Neither the clamped tube or the streaked solutions are idea in all cases
    // So we use the view angle to the light and the view angle to the surface normal
    // to blend between the two solutions.
    // ************************************************************************************
    float lightAngle = pow(2.0 * min(.5, min(uDiff, vDiff)), 2);
    float surfaceAngle = 1.0 - (2.0 * min(.5, NV));    
    float3 closestW = lerp(radialIntersect, reflectIntersect, min(1.0, lightAngle+surfaceAngle));
    
    // convert the closest intersection with the light back to a ray originating from the surface point.
    // ************************************************************************************
    return closestW + ltCenter - Pw;
} 

irradiance aiRectangleAreaLight_2020( float lightOn, bool lightActive, float intensity, float3 color, float emitDiff, float emitSpec, 
                      float3 LP0, float3 LP1, float3 LP2, float3 LP3,  float3 Pw, float3 Nw, float3 Vw,
                      float decayRate, bool useArea)
{ 
    float3  ltPts[4] = { LP3, LP2, LP1, LP0 }; 
    float3  T = ddx( Pw ); 
    float3  B = ddy( Pw ); 
    float3  fN = normalize( cross( T, B )); 
    Nw = (dot( fN, Nw ) < 0.0f) ? -Nw : Nw; 
    float sumNG = 0; 
    for( int i = 0; i < 4; ++i ) { 
       int nextI = (i == 3)? 0 : (i+1);  
       float3 Li = normalize(ltPts[i] - Pw); 
       float3 Ln = normalize(ltPts[nextI] - Pw); 
       float3 Gi = normalize( cross(Ln, Li) ); 
       float bi = acos( dot(Ln, Li) ); 
       sumNG += bi * dot( Gi, Nw ); 
    } 
    float ff = sumNG / 2.0f;
    float sf = 1.0f;
    float3 ltCenter = (ltPts[0]+ltPts[1]+ltPts[2]+ltPts[3])/4.0f; 
    float area = length(ltPts[1]-ltPts[0]) * length(ltPts[3]-ltPts[0]); 
    
    float3 Ls = aiGetRectangleReflection( ltPts, ltCenter, Pw, Nw, Vw, area); 
    if (useArea) 
    {
        ff = ff / area;
        sf = sf / area;
    }
    float3 clr = lightOn * color * intensity;  
    float3 Lp = aiNearestPtOnLt( ltPts, ltCenter, Pw ); 
    float3 Ld = Lp - Pw;  
    irradiance irrad; 
    irrad.diffuseI = emitDiff * clr * ff; 
    irrad.specularI = emitSpec * clr * sf; 
    irrad.Ls = normalize(Ls);  
    irrad.Ld = normalize(Ld); 
    irrad.Lg = float4(0.0f, 0.0f, 0.0f, 1.0f); 
    irrad.lightType = 0x00115C86; // set unique light type identifier (node id)
    return irrad; 
} 
            ]]>
        </source>
    </implementation>
      <implementation  render="OGSRenderer" language="GLSL" lang_version="3.0" >
        <function_name val="aiRectangleAreaLight_2020" />
        <source>
          <![CDATA[
// Find the closest point to a rectangular light source in 3D space
// ********************************************************************************
vec3 aiNearestPtOnLt( vec3 ltPts[4], vec3 ltCenter, vec3 Pw )
{ 
    // finds the closest point
    vec3 V = ( ltPts[1]-ltPts[0] ); 
    float lenV = length( V ); 
    V /= lenV;  lenV *= 0.5; 
    vec3 U = ( ltPts[3]-ltPts[0] ); 
    float lenU = length( U ); 
    U /= lenU;  lenU *= 0.5f; 
    vec3 L = Pw - ltCenter; 
    float LU = dot( L, U ); 
    float LV = dot( L, V ); 
    vec3 Lw = ltCenter 
                 +  U * clamp( LU, -lenU, lenU ) 
                 +  V * clamp( LV, -lenV, lenV ); 
    return Lw;  
} 

vec3 aiPlaneIntersection(vec3 ray, vec3 planeNormal, vec3 ptOnPlane, vec3 rayOrigin)
{
    float deltaD = dot(ptOnPlane, planeNormal) - dot(rayOrigin, planeNormal);
    float cosA = dot(ray, planeNormal);
    float lenToEdge = abs(cosA) < 0.00000001 ? 9999999.9 : deltaD / cosA;
    return ray * vec3(lenToEdge, lenToEdge, lenToEdge) + rayOrigin;
}

// Find the closest point to tube shaped light source along the reflection ray
// ********************************************************************************
vec3 aiGetTubeReflection(vec3 L0, vec3 L1, vec3 R, float halfHeight)
{
    vec3 Ld = L1 - L0;
    float RdotL0 = dot(R, L0);
    float RdotLd = dot(R, Ld);
    float L0dotLd = dot(L0, Ld);
    float distLd = length(Ld);
    float t = (RdotL0 * RdotLd - L0dotLd) / (distLd * distLd - RdotLd * RdotLd);

    vec3 closestPoint = L0 + Ld * clamp(t, 0.0f, 1.0f);
    vec3 centerToRay = R * dot(closestPoint, R) - closestPoint;
    return closestPoint + centerToRay * clamp(halfHeight / length(centerToRay), 0.0f, 1.0f);
}

// find the closest point to a rectangular light source along the reflection ray
// **************************************************************
vec3 aiGetStreakedReflection(vec3 dLIn, vec3 origin, vec3 U, vec3 V, float lenU, float lenV)
{   
    vec3 dL = dLIn;
    
    vec3 vnRayAtoB = normalize(dL - origin); 

    // compute the closest point to the axis 
    float LV = dot(dL, V); 
    float vError = abs(LV) - lenV; 
    LV = clamp(LV, -lenV, lenV); 
    vec3 VOff = V * vec3(LV, LV, LV);
    
    dL = (vError > 0.0) ? aiPlaneIntersection(vnRayAtoB, V, VOff, origin) : dL; 
    
    // compute the closest point to the second axis 
    float LU = dot(dL, U); 
    float uError = abs(LU) - lenU; 
    LU = clamp(LU, -lenU, lenU); 
    vec3 UOff = U * vec3(LU, LU, LU); 
    
    dL = (uError > 0.0) ? aiPlaneIntersection(vnRayAtoB, U, UOff, origin) : dL; 
    
    LV = dot(dL, V); 
    LV = clamp(LV, -lenV, lenV); 
    
    VOff = V * vec3(LV, LV, LV); 
    return VOff + UOff; 
}

vec3 aiGetRectangleReflection( vec3 ltPts[4], vec3 ltCenter, vec3 Pw, vec3 Nw, vec3 Vw, float area)
{    
    vec3 U = ( ltPts[1]-ltPts[0] ); 
    vec3 V = ( ltPts[3]-ltPts[0] ); 
    vec3 R = reflect( -Vw, Nw ); 
    
    float lenU = length(U); 
    float lenV = length(V); 
    
    float uDiff = abs(dot(-Vw, normalize(cross(R, U)))); 
    float vDiff = abs(dot(-Vw, normalize(cross(R, V)))); 
  
    U /= lenU;  lenU *= 0.5; 
    V /= lenV;  lenV *= 0.5; 
 
    vec3 ltN = normalize( cross( V, U )); 
    float LtPlaneD = dot(ltN, ltPts[0] ); 
    float ptPlaneDist = LtPlaneD - dot(ltN, Pw);     
    float LN = dot(ltN, -Nw);
    float NV = dot( -Vw, Nw ); 
       
    // Find the intersection point of the reflection ray and the light plane 
    // Early out if the ray does not hit the front of the light.
    // ************************************************************************************
    float LR = dot( ltN, R ); 
    if (LR <= 0.0) 
        return -R; 
    float t = ptPlaneDist / LR; 
    if (t <= 0.0) 
        return -R; 
        
    vec3 Rint = Pw + R * t; 
    vec3 dL = Rint - ltCenter; 

    // We compute the plane ray intersection in light plane space.
    // So compute the ray start on the light plane by projecting the surface point along the 
    // light normal until it hits the light plane.
    // ************************************************************************************
    vec3 origin = Pw + (Nw * (-ptPlaneDist / LN)) - ltCenter; 
    vec3 reflectIntersect = aiGetStreakedReflection(dL, origin, U, V, lenU, lenV);      

    // Next, find the intersection point of the reflection ray with a tube around the light
    // ************************************************************************************
    vec3 endPoint1 = (ltCenter + U * -lenU) - Pw;
    vec3 endPoint2 = (ltCenter + U *  lenU) - Pw;
    vec3 radialIntersect = aiGetTubeReflection(endPoint1, endPoint2, R, lenV);

    // Project the new intersection point with the tube onto the light plane
    // ************************************************************************************
    LR = dot( ltN, radialIntersect ); 
    t = max(ptPlaneDist / LR, 0.0f); 
    Rint = Pw + radialIntersect * t; 
    dL = Rint - ltCenter; 
    
    // and clamp the intersections to the edges of the light
    // ************************************************************************************
    float LV = clamp(dot(dL, V), -lenV, lenV); 
    float LU = clamp(dot(dL, U), -lenU, lenU); 
    radialIntersect = (LV * V) + (LU * U);
 
    // Neither the clamped tube or the streaked solutions are idea in all cases
    // So we use the view angle to the light and the view angle to the surface normal
    // to blend between the two solutions.
    // ************************************************************************************
    float lightAngle = 2.0 * min(.5, min(uDiff, vDiff));
    float surfaceAngle = 1.0 - (2.0 * min(.5, abs(NV)));    
    vec3 closestW = lerp(radialIntersect, reflectIntersect, min(1.0, lightAngle+surfaceAngle));
    
    // convert the closest intersection with the light back to a ray originating from the surface point.
    // ************************************************************************************
    return closestW - Pw + ltCenter;
} 

irradiance aiRectangleAreaLight_2020( float lightOn, bool lightActive, float intensity, vec3 color, float emitDiff, float emitSpec, 
                      vec3 LP0, vec3 LP1, vec3 LP2, vec3 LP3,  vec3 Pw, vec3 Nw, vec3 Vw,
                      float decayRate, bool useArea)
{ 
    vec3  ltPts[4] = vec3[] ( LP3, LP2, LP1, LP0 ); 
    vec3  T = dFdx( Pw ); 
    vec3  B = dFdy( Pw ); 
    vec3  fN = normalize( cross( T, B )); 
    Nw = (dot( fN, Nw ) < 0.0f) ? -Nw : Nw; 
    float sumNG = 0; 
    for( int i = 0; i < 4; ++i ) { 
       int nextI = (i == 3)? 0 : (i+1);  
       vec3 Li = normalize(ltPts[i] - Pw); 
       vec3 Ln = normalize(ltPts[nextI] - Pw); 
       vec3 Gi = normalize( cross(Ln, Li) ); 
       float bi = acos( dot(Ln, Li) ); 
       sumNG += bi * dot( Gi, Nw ); 
    } 
    float ff = sumNG / 2.0f;
    float sf = 1.0f;
    vec3 ltCenter = (ltPts[0]+ltPts[1]+ltPts[2]+ltPts[3])/vec3(4.0f, 4.0f, 4.0f); 
    float area = length(ltPts[1]-ltPts[0]) * length(ltPts[3]-ltPts[0]); 
    
    vec3 Ls = aiGetRectangleReflection( ltPts, ltCenter, Pw, Nw, Vw, area); 
    if (useArea) 
    {
        ff = ff / area;
        sf = sf / area;
    }
    vec3 clr = lightOn * color * intensity;
    vec3 Lp = aiNearestPtOnLt( ltPts, ltCenter, Pw );
    vec3 Ld = Lp - Pw;  
    irradiance irrad; 
    irrad.diffuseI = emitDiff * clr * ff;
    irrad.specularI = emitSpec * clr * sf;
    irrad.Ls = normalize(Ls);  
    irrad.Ld = normalize(Ld); 
    irrad.Lg = vec4(0.0f, 0.0f, 0.0f, -1.0f);
    irrad.lightType = 0x00115C86; // set unique light type identifier (node id)
    return irrad; 
} 
            ]]>
        </source>
      </implementation>
    </implementation>
</fragment>

