<fragment uiName="standardShaderSpecular" name="standardShaderSpecular" type="plumbing" class="ShadeFragment" version="1.0" feature_level="0">
    <description><![CDATA[Fragment for the arnold standard shader.]]></description>
    <properties>
        <struct name="lightingData" struct_name="standardShaderLightingData" />
        <float name="roughness" />
        <float name="IOR" />
        <float name="Ks" />
    </properties>
    <values>
        
    </values>
    <outputs>
        <float3 name="outColor" />
    </outputs>
    <implementation>
        <implementation render="OGSRenderer" language="Cg" lang_version="2.1">
            <function_name val="standardShaderSpecular" />
            <source>
                <![CDATA[
float SQR(float a)
{
    return a * a;
}

// Specular Functions
float3 standardShaderSpecular(
        standardShaderLightingData lightingData,
        float roughness, float IOR, float weight)
{
    const float M_PI = 3.14159265358;
    
    float rx = SQR(saturate(roughness));    
    rx = max(rx, 0.002f);   
    float rx2 = SQR(rx);
    
    if (length(lightingData.SL) == 0.0)
        return float3(0.0f, 0.0f, 0.0f);
        
    float NL = saturate(dot(lightingData.N, lightingData.L)); 
    if (NL == 0.0f)
        return float3(0.0f, 0.0f, 0.0f);
	  float NV = saturate(dot(lightingData.N, lightingData.V)); 
    if (NV == 0.0f)
        return float3(0.0f, 0.0f, 0.0f);
    
    float3 H = normalize(lightingData.SL + lightingData.V);
    float NH = dot(H, lightingData.N);   
    if (NH <= 0.0f) return float3(0.0f, 0.0f, 0.0f);
    
    float NH2 = SQR(NH);
    float NH4 = SQR(NH2);    
    float tan2ThetaM = (1.0f - NH2 ) / NH2;

    // not exactly a ggx distribution function????    
    //    D = e^((-(1.0f - NH^2) / (NH^2)) / rougness^4) 
    //        / (1.0f + M_PI * roughness^4 * NH^4);
    float D = exp(-tan2ThetaM / rx2) / (1.0f + M_PI * rx2 * NH4);  
    
    float k = SQR(roughness+1.0f)/8.0f;
    float G1 = NV / (NV * (1.0 - k) + k);
    float G2 = NL / (NL * (1.0 - k) + k);
    float G = (G1 * G2);
    
    //float atten = (1.0 + M_PI * roughness);
    float3 spec = (lightingData.specular); // / float3(atten, atten, atten);
    
    // compute the fresnel factors for the specular, coat, and transmission layers
    float fresnel = 1.0;
    if (NV >= 0.0f)
    {
        float HV = dot(H, lightingData.V);
        float R0 = abs((1.0 - IOR) / (1.0 + IOR));
        R0 = R0 * R0;      

        fresnel = R0 + (1.0-R0)*pow(1.0-HV, 5);
    } 
    fresnel *= weight;
    
    return (spec * D * G * fresnel) / ( 2.0 * NV );
} 
                ]]>
            </source>
        </implementation>
        <implementation render="OGSRenderer" language="HLSL" lang_version="11.0">
            <function_name val="standardShaderSpecular" />
            <source>
                <![CDATA[
float SQR(float a)
{
    return a * a;
}

// Specular Functions
float3 standardShaderSpecular(
        standardShaderLightingData lightingData,
        float roughness, float IOR, float weight)
{
    const float M_PI = 3.14159265358;
    
    float rx = SQR(saturate(roughness));    
    rx = max(rx, 0.002f);   
    float rx2 = SQR(rx);
    
    if (length(lightingData.SL) == 0.0)
        return float3(0.0f, 0.0f, 0.0f);
        
    float NL = saturate(dot(lightingData.N, lightingData.L)); 
    if (NL == 0.0f)
        return float3(0.0f, 0.0f, 0.0f);
	  float NV = saturate(dot(lightingData.N, lightingData.V)); 
    if (NV == 0.0f)
        return float3(0.0f, 0.0f, 0.0f);
    
    float3 H = normalize(lightingData.SL + lightingData.V);
    float NH = dot(H, lightingData.N);   
    if (NH <= 0.0f) return float3(0.0f, 0.0f, 0.0f);
    
    float NH2 = SQR(NH);
    float NH4 = SQR(NH2);    
    float tan2ThetaM = (1.0f - NH2 ) / NH2;

    // not exactly a ggx distribution function????    
    //    D = e^((-(1.0f - NH^2) / (NH^2)) / rougness^4) 
    //        / (1.0f + M_PI * roughness^4 * NH^4);
    float D = exp(-tan2ThetaM / rx2) / (1.0f + M_PI * rx2 * NH4);  
    
    float k = SQR(roughness+1.0f)/8.0f;
    float G1 = NV / (NV * (1.0 - k) + k);
    float G2 = NL / (NL * (1.0 - k) + k);
    float G = (G1 * G2);
    
    float atten = (1.0 + M_PI * roughness);
    float3 spec = (lightingData.specular) / atten;
    
    // compute the fresnel factors for the specular, coat, and transmission layers
    float fresnel = 1.0;
    if (NV >= 0.0f)
    {
        float HV = dot(H, lightingData.V);
        
        float R0 = abs((1.0 - IOR) / (1.0 + IOR));
        R0 = R0 * R0;      

        fresnel = (R0 + (1.0-R0)*pow(1.0-HV, 5));
    } 
    
    fresnel *= weight;
    
    return (spec * D * G * fresnel) / ( 2.0 * NV );
}    
                ]]>
            </source>
        </implementation>
        <implementation render="OGSRenderer" language="GLSL" lang_version="3.0">
            <function_name val="standardShaderSpecular" />
            <source>
                <![CDATA[
float SQR(float a)
{
    return a * a;
}

// Specular Functions
vec3 standardShaderSpecular(
        standardShaderLightingData lightingData,
        float roughness, float IOR, float weight)
{
    const float M_PI = 3.14159265358;
    
    float rx = SQR(saturate(roughness));    
    rx = max(rx, 0.002f);   
    float rx2 = SQR(rx);
    
    if (length(lightingData.SL) == 0.0)
        return vec3(0.0f, 0.0f, 0.0f);
        
    float NL = clamp(dot(lightingData.N, lightingData.L), 0.0, 1.0); 
    if (NL == 0.0f)
        return vec3(0.0f, 0.0f, 0.0f);
	  float NV = clamp(dot(lightingData.N, lightingData.V), 0.0, 1.0); 
    if (NV == 0.0f)
        return vec3(0.0f, 0.0f, 0.0f);
    
    vec3 H = normalize(lightingData.SL + lightingData.V);
    float NH = dot(H, lightingData.N);   
    if (NH <= 0.0f) return vec3(0.0f, 0.0f, 0.0f);
    
    float NH2 = SQR(NH);
    float NH4 = SQR(NH2);    
    float tan2ThetaM = (1.0f - NH2 ) / NH2;

    // not exactly a ggx distribution function????    
    //    D = e^((-(1.0f - NH^2) / (NH^2)) / rougness^4) 
    //        / (1.0f + M_PI * roughness^4 * NH^4);
    float D = exp(-tan2ThetaM / rx2) / (1.0f + M_PI * rx2 * NH4);  
    
    float k = SQR(roughness+1.0f)/8.0f;
    float G1 = NV / (NV * (1.0 - k) + k);
    float G2 = NL / (NL * (1.0 - k) + k);
    float G = (G1 * G2);
    
    float atten = (1.0 + M_PI * roughness);
    vec3 spec = (lightingData.specular) / atten;
    
    // compute the fresnel factors for the specular, coat, and transmission layers
    float fresnel = 1.0;
    if (NV >= 0.0f)
    {
        float HV = dot(H, lightingData.V);
        float R0 = abs((1.0 - IOR) / (1.0 + IOR));
        R0 = R0 * R0;      

        fresnel = R0 + (1.0-R0)*pow(1.0-HV, 5);
    } 
    fresnel *= weight;
    
    return (spec * D * G * fresnel) / ( 2.0 * NV );
} 
                ]]>
            </source>
        </implementation>
    </implementation>
</fragment>
