<fragment  uiName="aiRectangleAreaLight" name="aiRectangleAreaLight" type="lighting" class="ShadeFragment" version="1.0" feature_level="0" >
    <description>
<![CDATA[
Computes irradiance from a rectangle area light, w/ specular]]>
</description>
    <properties>
        <float  name="lightOn" flags="isNotSharableParam" />
        <bool  name="lightActive" flags="isNotSharableParam" />
        <float  name="intensity" flags="isNotSharableParam" />
        <color  name="color" flags="isNotSharableParam" />
        <float  name="emitsDiffuse" flags="isNotSharableParam" />
        <float  name="emitsSpecular" flags="isNotSharableParam" />
        <float3  name="LP0" flags="isNotSharableParam" />
        <float3  name="LP1" flags="isNotSharableParam" />
        <float3  name="LP2" flags="isNotSharableParam" />
        <float3  name="LP3" flags="isNotSharableParam" />
        <float3  name="Pw" flags="varyingInputParam" />
        <float3  name="Nw" flags="varyingInputParam" />
        <float3  name="Vw" flags="varyingInputParam" />
        <float  name="decayRate" flags="isNotSharableParam" />
        <bool  name="normalize" flags="isNotSharableParam" />
        <float3  name="viewDirection" semantic="viewdirection" />
    </properties>
    <values>
<float name="lightOn" value="1.000000"  />
<bool name="lightActive" value="false"  />
<float name="intensity" value="1.000000"  />
<color name="color" value="1.000000,1.000000,1.000000"  />
<float name="emitsDiffuse" value="1.000000"  />
<float name="emitsSpecular" value="1.000000"  />
<float3 name="LP0" value="-10.000000,10.000000,-10.000000"  />
<float3 name="LP1" value="-10.000000,-10.000000,-10.000000"  />
<float3 name="LP2" value="10.000000,-10.000000,-10.000000"  />
<float3 name="LP3" value="10.000000,10.000000,-10.000000"  />
<float name="decayRate" value="0.000000"  />
<bool name="normalize" value="false"  />
    </values>
    <outputs>
        <struct  name="aiRectangleAreaLight" struct_name="irradiance" />
    </outputs>
    <implementation  >
    <implementation  render="OGSRenderer" language="Cg" lang_version="2.100000" >
        <function_name val="aiRectangleAreaLight" />
        <source>
            <![CDATA[
float3 nearestPtOnLt( float3 ltPts[4], float3 ltCenter, float3 Pw )
{ 
    float3 V = ( ltPts[1]-ltPts[0] ); 
    float lenV = length( V ); 
    V /= lenV;  lenV *= 0.5; 
    float3 U = ( ltPts[3]-ltPts[0] ); 
    float lenU = length( U ); 
    U /= lenU;  lenU *= 0.5f; 
    float3 L = Pw - ltCenter; 
    float LU = dot( L, U ); 
    float LV = dot( L, V ); 
    float3 Lw = ltCenter 
                 +  U * clamp( LU, -lenU, lenU ) 
                 +  V * clamp( LV, -lenV, lenV ); 
    return Lw;  
} 
float3 planeIntersection(float3 ray, float3 planeNormal, float3 ptOnPlane, float3 rayOrigin) 
{ 
    float deltaD = dot(ptOnPlane, planeNormal) - dot(rayOrigin, planeNormal); 
    float cosA = dot(ray, planeNormal); 
    float lenToEdge = abs(cosA) < 0.00000001 ? 9999999.9 : deltaD / cosA; 
    return ray * lenToEdge + rayOrigin; 
} 
float3 getRectangleForSpecular( float3 ltPts[4], float3 ltCenter, float3 Pw, float3 Nw, float3 Vw, float area, float3 viewDirection )
{ 
    float3 V = ( ltPts[1]-ltPts[0] ); 
    float3 U = ( ltPts[3]-ltPts[0] ); 
    float3 R = reflect( -Vw, Nw ); 
    
    float uDiff = abs(dot(viewDirection, normalize(cross(R, U)))); 
    float vDiff = abs(dot(viewDirection, normalize(cross(R, V)))); 
    
    bool vAxisFirst = uDiff < vDiff; 
    float3 firstAxis = vAxisFirst ? V : U; 
    float3 secondAxis = !vAxisFirst ? V : U; 
    
    float lenFirst = length(firstAxis); 
    float lenSecond = length(secondAxis); 
    firstAxis /= lenFirst;  lenFirst *= 0.5; 
    secondAxis /= lenSecond;  lenSecond *= 0.5f; 
    
    float3 ltN = normalize( cross( V,U )); 
    float LtPlaneD = dot(ltN, ltPts[0] ); 
    float ptPlaneDist = LtPlaneD - dot(ltN, Pw); 
    float LR = dot( ltN, R ); 
    if (LR <= 0.0) 
        return -Vw; 
    float t = max(ptPlaneDist / LR, 0.0f); 
    if (t <= 0.0) 
        return -Vw; 
    float3 Rint = Pw + t * R; 
    float3 dL = Rint - ltCenter; 
    t = max(ptPlaneDist / dot(ltN, -Nw), 0.0f); 
    float3 PwOnPlane = Pw + (-Nw * t) - ltCenter; 
    float3 vnRayAtoB = normalize(dL - PwOnPlane); 
    
    float viewAngle = 4.0 * min(.25, min(uDiff, vDiff)); 
    //float viewAngle = 5.0 * min(.2, min(uDiff, vDiff)); 
    float ang2 = 4.0 * min(.25, LR); // anything over an LR of .2 is blurred  
    //float ang2 = 2.0 * min(.5, max(0.0, LR - .1)); // anything over an LR of .2 is blurred  
    float ang = lerp(1.0, viewAngle*viewAngle, pow(ang2, 6)); 
    //float ang = lerp(1.0, viewAngle*viewAngle, pow(ang2, .25)); 
    ang2 = 2.0 * min(.5, 1.0 - LR); 
    ang = lerp(0.0, ang, ang2); 
    
// compute the closest point to the axis 
    float LV = dot(dL, secondAxis); 
    float vError = abs(LV) - lenSecond; 
    LV = clamp(LV, -lenSecond, lenSecond); 
    float3 VOff = secondAxis * LV; 
    if (vError > 0) 
    { 
        dL = planeIntersection(vnRayAtoB, secondAxis, VOff, PwOnPlane); 
    } 
    // compute the closest point to the second axis 
    float LU = dot(dL, firstAxis); 
    float uError = abs(LU) - lenFirst; 
    LU = clamp(LU, -lenFirst, lenFirst); 
    float3 UOff = firstAxis * LU; 
    if (uError > 0) 
    { 
        dL = planeIntersection(vnRayAtoB, firstAxis, UOff, PwOnPlane); 
    } 
    float newLV = dot(dL, secondAxis); 
    //vError = abs(newLV) - lenSecond; 
    newLV = clamp(newLV, -lenSecond, lenSecond); 
    //float ang = 16.0 * (clamp(viewAngle, 0.0, .125)); 
    //float ang = sqrt(8.0 * clamp(LR, 0.0, .125)); 
    //float ang = pow(LR, 3.0) / (viewAngle * .8); 
    //float ang2 = (1.0 - sqrt((LR + NV)*.5)); 
    //ang = clamp(ang, 0.0, 1.0); 
    LV = lerp(LV, newLV, ang); 
    //if (vError > 0.0) 
    //{ 
    //    LV -= sign(LV) * min(vError, (.125 * lenSecond)) * viewAngle * (10.0 * (1.0 - LR)); 
    //    LV = clamp(LV, -lenSecond, lenSecond); 
    //} 
    VOff = secondAxis * LV; 
   float3 closestW = (VOff + UOff) + ltCenter; 
   return closestW - Pw; 
} 
irradiance aiRectangleAreaLight( float lightOn, bool lightActive, float intensity, float3 color, float emitDiff, float emitSpec, 
                      float3 LP0, float3 LP1, float3 LP2, float3 LP3,  float3 Pw, float3 Nw, float3 Vw,
                      float decayRate, bool useArea, float3 viewDirection)
{ 
    float3  ltPts[4] = { LP3, LP2, LP1, LP0 }; 
    float3  T = ddx( Pw ); 
    float3  B = ddy( Pw ); 
    float3  fN = normalize( cross( T, B )); 
    Nw = (dot( fN, Nw ) < 0.0f) ? -Nw : Nw; 
    float sumNG = 0; 
    for( int i = 0; i < 4; ++i ) { 
       int nextI = (i == 3)? 0 : (i+1);  
       float3 Li = normalize(ltPts[i] - Pw); 
       float3 Ln = normalize(ltPts[nextI] - Pw); 
       float3 Gi = normalize( cross(Ln, Li) ); 
       float bi = acos( dot(Ln, Li) ); 
       sumNG += bi * dot( Gi, Nw ); 
    } 
    const float M_2PI = 3.14159265358 * 2.0; 
    float ff = sumNG / M_2PI; 
    float sf = 1.0; 
    float3 ltCenter = (ltPts[0]+ltPts[1]+ltPts[2]+ltPts[3])/4.0f; 
    float area = length(ltPts[1]-ltPts[0]) * length(ltPts[3]-ltPts[0]); 
    float3 Ls = getRectangleForSpecular( ltPts, ltCenter, Pw, Nw, Vw, area, viewDirection); 
    if (useArea) 
    {
        ff = ff / area;
        sf = sf / area;
    }
    float3 clr = lightOn * color * intensity;  
    float3 Lp = nearestPtOnLt( ltPts, ltCenter, Pw ); 
    float3 Ld = Lp - Pw;  
    irradiance irrad; 
    irrad.diffuseI = emitDiff * clr * ff; 
    irrad.specularI = emitSpec * clr * sf; 
    irrad.Ls = Ls / sqrt(area);  
    irrad.Ld = normalize( Ld ); 
    irrad.Lg = float4(0.0f, 0.0f, 0.0f, 1.0f); 
    return irrad; 
} 
            ]]>
        </source>
    </implementation>
    <implementation  render="OGSRenderer" language="HLSL" lang_version="11.000000" >
        <function_name val="aiRectangleAreaLight" />
        <source>
            <![CDATA[
float3 nearestPtOnLt( float3 ltPts[4], float3 ltCenter, float3 Pw )
{ 
    float3 V = ( ltPts[1]-ltPts[0] ); 
    float lenV = length( V ); 
    V /= lenV;  lenV *= 0.5; 
    float3 U = ( ltPts[3]-ltPts[0] ); 
    float lenU = length( U ); 
    U /= lenU;  lenU *= 0.5f; 
    float3 L = Pw - ltCenter; 
    float LU = dot( L, U ); 
    float LV = dot( L, V ); 
    float3 Lw = ltCenter 
                 +  U * clamp( LU, -lenU, lenU ) 
                 +  V * clamp( LV, -lenV, lenV ); 
    return Lw;  
} 
float3 planeIntersection(float3 ray, float3 planeNormal, float3 ptOnPlane, float3 rayOrigin) 
{ 
    float deltaD = dot(ptOnPlane, planeNormal) - dot(rayOrigin, planeNormal); 
    float cosA = dot(ray, planeNormal); 
    float lenToEdge = abs(cosA) < 0.00000001 ? 9999999.9 : deltaD / cosA; 
    return ray * lenToEdge + rayOrigin; 
} 
float3 getRectangleForSpecular( float3 ltPts[4], float3 ltCenter, float3 Pw, float3 Nw, float3 Vw, float area, float3 viewDirection )
{ 
    float3 V = ( ltPts[1]-ltPts[0] ); 
    float3 U = ( ltPts[3]-ltPts[0] ); 
    float3 R = reflect( -Vw, Nw ); 
    
    float uDiff = abs(dot(viewDirection, normalize(cross(R, U)))); 
    float vDiff = abs(dot(viewDirection, normalize(cross(R, V)))); 
    
    bool vAxisFirst = uDiff < vDiff; 
    float3 firstAxis = vAxisFirst ? V : U; 
    float3 secondAxis = !vAxisFirst ? V : U; 
    
    float lenFirst = length(firstAxis); 
    float lenSecond = length(secondAxis); 
    firstAxis /= lenFirst;  lenFirst *= 0.5; 
    secondAxis /= lenSecond;  lenSecond *= 0.5f; 
    
    float3 ltN = normalize( cross( V,U )); 
    float LtPlaneD = dot(ltN, ltPts[0] ); 
    float ptPlaneDist = LtPlaneD - dot(ltN, Pw); 
    float LR = dot( ltN, R ); 
    if (LR <= 0.0) 
        return -Vw; 
    float t = max(ptPlaneDist / LR, 0.0f); 
    if (t <= 0.0) 
        return -Vw; 
    float3 Rint = Pw + t * R; 
    float3 dL = Rint - ltCenter; 
    t = max(ptPlaneDist / dot(ltN, -Nw), 0.0f); 
    float3 PwOnPlane = Pw + (-Nw * t) - ltCenter; 
    float3 vnRayAtoB = normalize(dL - PwOnPlane); 
    
    float viewAngle = 4.0 * min(.25, min(uDiff, vDiff)); 
    //float viewAngle = 5.0 * min(.2, min(uDiff, vDiff)); 
    float ang2 = 4.0 * min(.25, LR); // anything over an LR of .2 is blurred  
    //float ang2 = 2.0 * min(.5, max(0.0, LR - .1)); // anything over an LR of .2 is blurred  
    float ang = lerp(1.0, viewAngle*viewAngle, pow(ang2, 6)); 
    //float ang = lerp(1.0, viewAngle*viewAngle, pow(ang2, .25)); 
    ang2 = 2.0 * min(.5, 1.0 - LR); 
    ang = lerp(0.0, ang, ang2); 
    
// compute the closest point to the axis 
    float LV = dot(dL, secondAxis); 
    float vError = abs(LV) - lenSecond; 
    LV = clamp(LV, -lenSecond, lenSecond); 
    float3 VOff = secondAxis * LV; 
    if (vError > 0) 
    { 
        dL = planeIntersection(vnRayAtoB, secondAxis, VOff, PwOnPlane); 
    } 
    // compute the closest point to the second axis 
    float LU = dot(dL, firstAxis); 
    float uError = abs(LU) - lenFirst; 
    LU = clamp(LU, -lenFirst, lenFirst); 
    float3 UOff = firstAxis * LU; 
    if (uError > 0) 
    { 
        dL = planeIntersection(vnRayAtoB, firstAxis, UOff, PwOnPlane); 
    } 
    float newLV = dot(dL, secondAxis); 
    //vError = abs(newLV) - lenSecond; 
    newLV = clamp(newLV, -lenSecond, lenSecond); 
    //float ang = 16.0 * (clamp(viewAngle, 0.0, .125)); 
    //float ang = sqrt(8.0 * clamp(LR, 0.0, .125)); 
    //float ang = pow(LR, 3.0) / (viewAngle * .8); 
    //float ang2 = (1.0 - sqrt((LR + NV)*.5)); 
    //ang = clamp(ang, 0.0, 1.0); 
    LV = lerp(LV, newLV, ang); 
    //if (vError > 0.0) 
    //{ 
    //    LV -= sign(LV) * min(vError, (.125 * lenSecond)) * viewAngle * (10.0 * (1.0 - LR)); 
    //    LV = clamp(LV, -lenSecond, lenSecond); 
    //} 
    VOff = secondAxis * LV; 
   float3 closestW = (VOff + UOff) + ltCenter; 
   return closestW - Pw; 
} 
irradiance aiRectangleAreaLight( float lightOn, bool lightActive, float intensity, float3 color, float emitDiff, float emitSpec, 
                      float3 LP0, float3 LP1, float3 LP2, float3 LP3,  float3 Pw, float3 Nw, float3 Vw,
                      float decayRate, bool useArea, float3 viewDirection)
{ 
    float3  ltPts[4] = { LP3, LP2, LP1, LP0 }; 
    float3  T = ddx( Pw ); 
    float3  B = ddy( Pw ); 
    float3  fN = normalize( cross( T, B )); 
    Nw = (dot( fN, Nw ) < 0.0f) ? -Nw : Nw; 
    float sumNG = 0; 
    for( int i = 0; i < 4; ++i ) { 
       int nextI = (i == 3)? 0 : (i+1);  
       float3 Li = normalize(ltPts[i] - Pw); 
       float3 Ln = normalize(ltPts[nextI] - Pw); 
       float3 Gi = normalize( cross(Ln, Li) ); 
       float bi = acos( dot(Ln, Li) ); 
       sumNG += bi * dot( Gi, Nw ); 
    } 
    const float M_2PI = 3.14159265358 * 2.0; 
    float ff = sumNG / M_2PI; 
    float sf = 1.0; 
    float3 ltCenter = (ltPts[0]+ltPts[1]+ltPts[2]+ltPts[3])/4.0f; 
    float area = length(ltPts[1]-ltPts[0]) * length(ltPts[3]-ltPts[0]); 
    float3 Ls = getRectangleForSpecular( ltPts, ltCenter, Pw, Nw, Vw, area, viewDirection); 
    if (useArea) 
    {
        ff = ff / area;
        sf = sf / area;
    }
    float3 clr = lightOn * color * intensity;  
    float3 Lp = nearestPtOnLt( ltPts, ltCenter, Pw ); 
    float3 Ld = Lp - Pw;  
    irradiance irrad; 
    irrad.diffuseI = emitDiff * clr * ff; 
    irrad.specularI = emitSpec * clr * sf; 
    irrad.Ls = Ls / sqrt(area);  
    irrad.Ld = normalize( Ld ); 
    irrad.Lg = float4(0.0f, 0.0f, 0.0f, 1.0f); 
    return irrad; 
} 
            ]]>
        </source>
    </implementation>
    </implementation>
</fragment>

